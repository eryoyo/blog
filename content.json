{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/blog/2022/04/28/hello-world/"},{"title":"使用hexo-icarus快速创建自己的博客网站","text":"使用hexo+icarus快速搭建属于自己的博客网站 准备环境 安装nodejs✅ 安装git✅ 安装hexo✅ 12# 此为全局安装，可能需要sudo权限npm install -g hexo-cli 创建git仓库直接在github主页创建一个新的仓库，此处假设仓库名称为blog_tensorrt 使用hexo建初始博客首先初始化一个博客项目，此处blog可以换成自己想要起的名称。该操作之后在当前目录下会出现一个叫做blog的新的文件夹 1hexo init blog 进入blog文件夹下 1cd blog 可以看到当前的文件夹下有一个themes的文件夹，此时看到里面没有文件，下载icarus主题代码到其中 1git clone git@github.com:ppoffice/hexo-theme-icarus.git /themes/icarus 之后修改_config.yml文件，将theme修改为icarus 1theme: icarus 之后在命令行进行构建 1hexo g 输入生成命令可能会报错，提示有没有安装的包，安装确实的包 1yarn add bulma-stylus@0.8.0 hexo-component-inferno@^1.1.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 接着生成 12# 该命令多执行几次，知道没有新的文件生成hexo g 查看网页初始效果 1hexo s 打开网页http://localhost:4000 自定义博客设计此时博客目录下有文件_config.icarus.yml，修改该文件即可，每一项在icarus官网https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#more均有详细的说明，在此不做赘述。 部署网站首先修改_config.yml文件 123456789101112# Sitetitle: eryoyo的博客subtitle: 坚持✊description: tensorrt笔记整理keywords: author: eryoyolanguage: zh-CNtimezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://eryoyo.github.io/blog_tensorrt 之后进行本地查看 123hexo cleanhexo ghexo s 网站可以在http://localhost:4000/blog_tensorrt里面查看到 之后接着修改_config.yml文件 1234deploy: type: git repo: git@github.com:eryoyo/blog_tensorrt.git branch: master 安装部署需要的包 1npm install hexo-deployer-git --save 之后部署 1hexo deploy 在仓库里面setting里面修改github pages的none为master分支，点击save，等待一会之后就可以在访问自己刚刚部署到的网站了","link":"/blog/2022/04/28/%E4%BD%BF%E7%94%A8hexo-icarus%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"title":"博客链接整理","text":"存放自己博客相关的链接 发博客平台 GitHub: https://eryoyo.github.io/blog/ 知乎: https://www.zhihu.com/creator/manage/creation/all CSDN: https://mp.csdn.net/ bilibili: https://member.bilibili.com/platform/home eryoyo: https://eryoyo.xyz/admin/login 微信公众号： https://mp.weixin.qq.com/cgi-bin/home 创建博客使用 github博客评论区管理： https://disqus.com/ https://disqus.com/home/ github博客markdown书写前front-matter管理和文档: https://hexo.io/zh-cn/docs/front-matter hexo主题市场: https://hexo.io/themes/ icarus主题配置: https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#%E5%AF%BC%E8%88%AA%E6%A0%8F icarus快速上手: https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#install-source icarus源码: https://github.com/ppoffice/hexo-theme-icarus 腾讯云控制台: 域名：https://console.cloud.tencent.com/domain 备案：https://console.cloud.tencent.com/beian/manage SSL证书：https://console.cloud.tencent.com/certoverview 服务器：https://console.cloud.tencent.com/lighthouse/instance/index eryoyo服务器模板源码: https://github.com/ZHENFENG13/My-Blog eryoyo网站配图： https://en.wikipedia.org/wiki/Limerick","link":"/blog/2022/04/28/%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%95%B4%E7%90%86/"},{"title":"linux系统中makefile书写规则","text":"本文自https://blog.csdn.net/haoel/article/details/2886整理而来，便于自己快速回顾makefile的书写。 基础规则makefile使得工程完成自动化编译，告诉make命令如何编译和链接程序。编译过程是指生成.o中间代码文件，链接是指将中间代码文件合起来成为可执行文件。编译关注的是语法正确和声明正确，链接会关注函数实现，也就是在所有的中间代码文件当中寻找函数实现，如果没有找到就会报错，需要指定中间代码文件位置。 下面是makefile的基础书写规则，也就是利用command来从prerequisites生成target。target表示目标文件，prerequisites表示生成target需要的文件，command表示任意的shell命令，以Tab键开头。 12target:prerequisites command 遵循着一个规律，也就是当target不存在的时候会直接生成，假如target存在，就会查看prerequisites是否比target新，假如是就重新生成target，也就是重新执行command。 常用的点 /表示换行","link":"/blog/2022/04/29/linux%E7%B3%BB%E7%BB%9F%E4%B8%ADmakefile%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/"},{"title":"刷题基础1","text":"主要总结使用C++刷题时会使用的一些基础知识 cstdio头文件：程序中处理输入输出 scanf printf %d %lld f% lf% c% s% 变量类型：int(9), long long(18), float(128), double(1024), char(127), bool(0,1) 0~9(48~57),A~Z(65~90),a~z(97~122) ^相同为0，不同为1 scanf(“%d:%d:%d”, &amp;hh, &amp;mm, &amp;ss) 除了%c以外，scanf对其他格式符例如%d、s%的输入是以空白符（空格、Tab）为结束判断标志的 %md:保持m位右对齐输出，不足m位用空格补齐 %0md:用0补齐 %.mf:使浮点数保留m位小数输出 getchar:输入单个字符，可识别换行符，putchar:输出单个字符 typedef long long ll:给long long起一个别名ll math函数：fabs(取浮点数绝对值),floor,ceil(向下、上取整)，pow(a, b):返回a的b次方，sqrt:算术平方根，log:以自然对数为底的对数，没有对任意底数求对数的函数，使用换底公式：以a为底b的对数=以自然对数为底b的对数除以以自然对数为底a的对数，sin,cos,tan,asin,acos,atan,pi=acos(-1.0)，round四舍五入 给数组赋初值0：int a[10] = {0} 当数组较大时应该定义在主函数的外面10^6 memset(数组名， 值， sizeof(数组名)):为数组里面的每一个元素赋相同的初值, string.h头文件，值=0赋全0，值=-1赋全1 字符串数组赋初值可以用字符串”hello world” scanf,printf输入输出：c%识别空格和换行，s%以空格和换行作为分隔符 getchar(),putchar(char)输入输出：识别换行符 gets(str),puts(str)输入输出：以换行符作为分隔符 字符数组的末尾有\\0,表示空字符，占用一个字符位 gets和printf会在末尾自动添加，此外需要自己添加\\0 string.h strlen(字符数组):返回\\0字符前的字符个数，不包含\\0 strcmp(字符数组a，字符数组b)：字典序排序, a == b:返回0, a &lt; b:返回负数, a &gt; b:返回正数 strcpy(字符数组a，字符数组b):将b复制给a,包括\\0 strcat(字符数组a，字符数组b):将b拼接到a后面 sscanf(str, “%d”, &amp;n):将str以整数的格式输出到n sprintf(str, “%d”, n):将n以整数的格式写到字符数组中 数组作为函数参数的时候，第一维不需要填写长度，第二维需要, 不允许返回数组 指针变量支持加减法操作和自增自减操作，操作单位为其基类型，例如int为其基类型, 储存的是int类型变量的地址，那么＋1之后指向当前变量的下一个int 数组名称可作为数组的首地址来使用 指针的引用：int* &amp;p指针本质也是一个无符号整数，所以可以使用引用 cin和cout:iostream char str[100]; cin.getline(str, 100); string str; getline(cin, str); cout设置小数精度：头文件iomanip, cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;123.4567&lt;&lt;endl输出123.46 浮点数的比较： const double eps = 1e-8 #define Equal(a, b) ((fabs((a) - (b))) &lt; (eps)) 圆周率π：const double pi = acos(-1.0) 0.00输出为-0.00只能先将结果存到字符串中然后与-0.00比较配合eps修正为0.00 sqrt,asin,acos配合eps使得变量在定义域内 scanf有返回值，代表成功读入的参数个数，如果读取失败则返回EOF while(scanf(“%d”, &amp;n) != EOF) while(gets(str) != NULL) 用一个结构体给另一个结构体赋值的时候，结构体里面假如有字符串数组，赋值的过程中不是用的地址，而是地址上面的值","link":"/blog/2022/04/29/%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%801/"},{"title":"刷题基础2","text":"总结使用C++刷题时STL的使用 vector 初始化： 123vector&lt;typename&gt; name;// vector数组:vector&lt;typename&gt; arrayname[size]; 访问： 12345678910// 通过下标vec[i];// 通过迭代器vector&lt;typename&gt;::iterator it = name.begin(); *it; it++;// 在常用的STL容器中只有vector和string允许使用it+i的用法*(vec.begin() + i); 操作： 1234567vec.push_back(x)vec.pop_back()vec.size()vec.clear() // 清空vector中所有元素vec.insert(it, x) // 在it所指位置处插入一个元素，当前位置原先的元素及其之后的元素后移vec.erase(it) // 删除it所指位置的元素vec.erase(it1, it2) //删除[it1,it2)区间内的所有元素 set 初始化： 123set&lt;typename&gt; name;// set数组set&lt;typename&gt; arrayname[size]; 访问： 1234// 通过迭代器set&lt;typename&gt;::iterator it = name.begin();*it; it++; 操作： 1234567name.insert(x) // 复杂度O(logn)name.find(x) // 返回集合中值为x的迭代器，时间复杂度为O(logn)name.erase(it) // 删除it所指位置的元素，时间复杂度为O(1)name.erase(x) // 删除集合中值为x的元素，复杂度为0(logn)name.erase(it1, it2) // 删除[it1, it2)区间内的元素name.size() // 获取元素的个数，复杂度为O(1)name.clear() // 清空所有元素，复杂度为O(n) 注： set的作用是去重并升序排序 multiset允许元素重复 unordered_set:其只实现去重不实现排序，速度更快，原理为散列实现代替set的红黑树（自平衡二叉树）实现 string 初始化： 12345string str = &quot;abcd&quot;;cin&gt;&gt;str; cout&lt;&lt;str;// scanf不能输入stringprintf(&quot;%s&quot;, str.c_str()); 访问元素： 123456// 通过下标// 通过迭代器：string::iterator it = str.begin();it++;*it; 常用函数： 12345678910111213141516171819str1 += str2; // 将str2拼接到str1后面str1 = str1 + str2;// ==, !=, &lt;, &lt;=, &gt;, &gt;=:以字典序比较两个字符串str.length();str.size();str.insert(pos, string); // 从下标为pos的位置开始插入字符串，该位置及其之后的元素全部后移str.insert(it, it1, it2); // 从it所指位置开始插入it1到it2之间的元素str.erase(it); // 删除单个元素str.erase(it1, it2); // 删除一个区间内的所有元素str.erase(pos, length); // 删除下标为pos开始的length个元素str.clear(); // 清空元素str.substr(pos, len); // 取出len个元素string::npos; // find函数失配时的返回值，常量-1或4294967295str1.find(str2); // 当str2是str1的子串的时候，返回第一次出现的位置，否则返回string::npos,复杂度为O(mn)str.replace(pos, len, str2);str.replace(it1, it2, str2); // 将范围内的字符串替换为str2，修改了原字符串 map 初始化： 1map&lt;typename1, typename2&gt; mp; // key可以为STL类型，但是不能用数组类型 访问元素： 12345678// 元素按照key的大小升序排序// 通过下标访问// 通过迭代器：map&lt;typename1, typename2&gt;::iterator it;it-&gt;first; it-&gt;second; 常用函数： 123456mp.find(key); // 返回key对应的元素的迭代器mp.erase(it);mp.erase(key);mp.erase(it1, it2);mp.size();mp.clear(); queue 初始化： 1queue&lt;typename&gt; name; 访问元素： 12q.front(); // 最先进入的元素; q.back(); 常用函数： 123456q.front();q.back();q.pop();q.push(x);q.empty();q.size(); priority_queue 初始化： 1priority_queue&lt;typename&gt; name; // 大顶堆 访问元素： 1q.top(); 常用函数： 12345q.push(x); // O(logn)q.top(); // O(1)q.pop(); // O(logn)q.empty(); // O(1)q.size() 自定义优先级队列： 12345678910111213141516171819202122// 基本数据类型：// 小顶堆：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;// 大顶堆(默认)：priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;// 结构体：// 重载&lt;符号：写在结构体里面friend bool operator &lt; (student a, student b){ return a.age &lt; b.age;//大顶堆 return a.age &gt; b.age;//小顶堆}priority_queue&lt;student&gt; q;// 重载：写在结构体外面struct cmp{ bool operator () (fruit f1, fruit f2){ return f1.price &lt; f2.price;//大顶堆 return f1.price &gt; f2.price;//小顶堆 }}priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q; stack 初始化： 1stack&lt;typename&gt; s; 访问元素： 1s.top(); 常用函数： 12345s.push(x);s.top();s.pop();s.empty();s.size(); pair 初始化： 123// utility头文件，包含了map头文件也就是包含了utility, map的元素为元组pair&lt;typename1, typename2&gt; name(e1, e2);p = make_pair(e1, e2); 访问元素： 12p.first;p.second; 常用函数： ==, !=, &lt;, &lt;=, &gt;, &gt;=,先比较first，再比较second algorithm12345678910111213max(a, b);min(a, b);abs(x);swap(a, b);reverse(it1, it2); // 将[it1, it2)范围内的元素翻转next_permutation(a, a + 5); // 返回下一个全排列fill(a, a + 5, 233); // 将数组指定范围内填充为指定数字sort(it1, it2, cmp); // it为指针或者迭代器bool cmp(int i1, int i2){ return i1 &gt; i2;//递减排列}lower_bound(it1, it2, val); // 返回第一个&gt;=val的元素, 否则返回可以插入该元素的指针或者迭代器, 找到则返回指针或迭代器upper_bound(it1, it2, val); // 返回第一个&gt;val的元素","link":"/blog/2022/04/29/%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%802/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/blog/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/blog/tags/icarus/"},{"name":"makefile","slug":"makefile","link":"/blog/tags/makefile/"},{"name":"基础","slug":"基础","link":"/blog/tags/%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"网站创建","slug":"网站创建","link":"/blog/categories/%E7%BD%91%E7%AB%99%E5%88%9B%E5%BB%BA/"},{"name":"个人小记","slug":"个人小记","link":"/blog/categories/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E8%AE%B0/"},{"name":"linux","slug":"linux","link":"/blog/categories/linux/"},{"name":"刷题笔记","slug":"刷题笔记","link":"/blog/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}]}