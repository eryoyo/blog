{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/blog/2022/04/28/hello-world/"},{"title":"使用hexo-icarus快速创建自己的博客网站","text":"使用hexo+icarus快速搭建属于自己的博客网站 准备环境 安装nodejs✅ 安装git✅ 安装hexo✅ 12# 此为全局安装，可能需要sudo权限npm install -g hexo-cli 创建git仓库直接在github主页创建一个新的仓库，此处假设仓库名称为blog_tensorrt 使用hexo建初始博客首先初始化一个博客项目，此处blog可以换成自己想要起的名称。该操作之后在当前目录下会出现一个叫做blog的新的文件夹 1hexo init blog 进入blog文件夹下 1cd blog 可以看到当前的文件夹下有一个themes的文件夹，此时看到里面没有文件，下载icarus主题代码到其中 1git clone git@github.com:ppoffice/hexo-theme-icarus.git /themes/icarus 之后修改_config.yml文件，将theme修改为icarus 1theme: icarus 之后在命令行进行构建 1hexo g 输入生成命令可能会报错，提示有没有安装的包，安装确实的包 1yarn add bulma-stylus@0.8.0 hexo-component-inferno@^1.1.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 接着生成 12# 该命令多执行几次，知道没有新的文件生成hexo g 查看网页初始效果 1hexo s 打开网页http://localhost:4000 自定义博客设计此时博客目录下有文件_config.icarus.yml，修改该文件即可，每一项在icarus官网https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#more均有详细的说明，在此不做赘述。 部署网站首先修改_config.yml文件 123456789101112# Sitetitle: eryoyo的博客subtitle: 坚持✊description: tensorrt笔记整理keywords: author: eryoyolanguage: zh-CNtimezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://eryoyo.github.io/blog_tensorrt 之后进行本地查看 123hexo cleanhexo ghexo s 网站可以在http://localhost:4000/blog_tensorrt里面查看到 之后接着修改_config.yml文件 1234deploy: type: git repo: git@github.com:eryoyo/blog_tensorrt.git branch: master 安装部署需要的包 1npm install hexo-deployer-git --save 之后部署 1hexo deploy 在仓库里面setting里面修改github pages的none为master分支，点击save，等待一会之后就可以在访问自己刚刚部署到的网站了","link":"/blog/2022/04/28/%E4%BD%BF%E7%94%A8hexo-icarus%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"title":"博客链接整理","text":"存放自己博客相关的链接 发博客平台 GitHub: https://eryoyo.github.io/blog/ 知乎: https://www.zhihu.com/creator/manage/creation/all CSDN: https://mp.csdn.net/ bilibili: https://member.bilibili.com/platform/home eryoyo: https://eryoyo.xyz/admin/login 微信公众号： https://mp.weixin.qq.com/cgi-bin/home 创建博客使用 github博客评论区管理： https://disqus.com/ https://disqus.com/home/ github博客markdown书写前front-matter管理和文档: https://hexo.io/zh-cn/docs/front-matter hexo主题市场: https://hexo.io/themes/ icarus主题配置: https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#%E5%AF%BC%E8%88%AA%E6%A0%8F icarus快速上手: https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#install-source icarus源码: https://github.com/ppoffice/hexo-theme-icarus 腾讯云控制台: 域名：https://console.cloud.tencent.com/domain 备案：https://console.cloud.tencent.com/beian/manage SSL证书：https://console.cloud.tencent.com/certoverview 服务器：https://console.cloud.tencent.com/lighthouse/instance/index eryoyo服务器模板源码: https://github.com/ZHENFENG13/My-Blog eryoyo网站配图： https://en.wikipedia.org/wiki/Limerick","link":"/blog/2022/04/28/%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%95%B4%E7%90%86/"},{"title":"linux系统中makefile书写规则","text":"本文自https://blog.csdn.net/haoel/article/details/2886整理而来，便于自己快速回顾makefile的书写。 基础规则makefile使得工程完成自动化编译，告诉make命令如何编译和链接程序。编译过程是指生成.o中间代码文件，链接是指将中间代码文件合起来成为可执行文件。编译关注的是语法正确和声明正确，链接会关注函数实现，也就是在所有的中间代码文件当中寻找函数实现，如果没有找到就会报错，需要指定中间代码文件位置。 下面是makefile的基础书写规则，也就是利用command来从prerequisites生成target。target表示目标文件，prerequisites表示生成target需要的文件，command表示任意的shell命令，以Tab键开头。 12target:prerequisites command 遵循着一个规律，也就是当target不存在的时候会直接生成，假如target存在，就会查看prerequisites是否比target新，假如是就重新生成target，也就是重新执行command。 常用的点 /表示换行","link":"/blog/2022/04/29/linux%E7%B3%BB%E7%BB%9F%E4%B8%ADmakefile%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99/"},{"title":"刷题基础1","text":"主要总结使用C++刷题时会使用的一些基础知识 cstdio头文件：程序中处理输入输出 scanf printf %d %lld f% lf% c% s% 变量类型：int(9), long long(18), float(128), double(1024), char(127), bool(0,1) 0~9(48~57),A~Z(65~90),a~z(97~122) ^相同为0，不同为1 scanf(“%d:%d:%d”, &amp;hh, &amp;mm, &amp;ss) 除了%c以外，scanf对其他格式符例如%d、s%的输入是以空白符（空格、Tab）为结束判断标志的 %md:保持m位右对齐输出，不足m位用空格补齐 %0md:用0补齐 %.mf:使浮点数保留m位小数输出 getchar:输入单个字符，可识别换行符，putchar:输出单个字符 typedef long long ll:给long long起一个别名ll math函数：fabs(取浮点数绝对值),floor,ceil(向下、上取整)，pow(a, b):返回a的b次方，sqrt:算术平方根，log:以自然对数为底的对数，没有对任意底数求对数的函数，使用换底公式：以a为底b的对数=以自然对数为底b的对数除以以自然对数为底a的对数，sin,cos,tan,asin,acos,atan,pi=acos(-1.0)，round四舍五入 给数组赋初值0：int a[10] = {0} 当数组较大时应该定义在主函数的外面10^6 memset(数组名， 值， sizeof(数组名)):为数组里面的每一个元素赋相同的初值, string.h头文件，值=0赋全0，值=-1赋全1 字符串数组赋初值可以用字符串”hello world” scanf,printf输入输出：c%识别空格和换行，s%以空格和换行作为分隔符 getchar(),putchar(char)输入输出：识别换行符 gets(str),puts(str)输入输出：以换行符作为分隔符 字符数组的末尾有\\0,表示空字符，占用一个字符位 gets和printf会在末尾自动添加，此外需要自己添加\\0 string.h strlen(字符数组):返回\\0字符前的字符个数，不包含\\0 strcmp(字符数组a，字符数组b)：字典序排序, a == b:返回0, a &lt; b:返回负数, a &gt; b:返回正数 strcpy(字符数组a，字符数组b):将b复制给a,包括\\0 strcat(字符数组a，字符数组b):将b拼接到a后面 sscanf(str, “%d”, &amp;n):将str以整数的格式输出到n sprintf(str, “%d”, n):将n以整数的格式写到字符数组中 数组作为函数参数的时候，第一维不需要填写长度，第二维需要, 不允许返回数组 指针变量支持加减法操作和自增自减操作，操作单位为其基类型，例如int为其基类型, 储存的是int类型变量的地址，那么＋1之后指向当前变量的下一个int 数组名称可作为数组的首地址来使用 指针的引用：int* &amp;p指针本质也是一个无符号整数，所以可以使用引用 cin和cout:iostream char str[100]; cin.getline(str, 100); string str; getline(cin, str); cout设置小数精度：头文件iomanip, cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;123.4567&lt;&lt;endl输出123.46 浮点数的比较： const double eps = 1e-8 #define Equal(a, b) ((fabs((a) - (b))) &lt; (eps)) 圆周率π：const double pi = acos(-1.0) 0.00输出为-0.00只能先将结果存到字符串中然后与-0.00比较配合eps修正为0.00 sqrt,asin,acos配合eps使得变量在定义域内 scanf有返回值，代表成功读入的参数个数，如果读取失败则返回EOF while(scanf(“%d”, &amp;n) != EOF) while(gets(str) != NULL) 用一个结构体给另一个结构体赋值的时候，结构体里面假如有字符串数组，赋值的过程中不是用的地址，而是地址上面的值","link":"/blog/2022/04/29/%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%801/"},{"title":"刷题基础2","text":"总结使用C++刷题时STL的使用 vector 初始化： 123vector&lt;typename&gt; name;// vector数组:vector&lt;typename&gt; arrayname[size]; 访问： 12345678910// 通过下标vec[i];// 通过迭代器vector&lt;typename&gt;::iterator it = name.begin(); *it; it++;// 在常用的STL容器中只有vector和string允许使用it+i的用法*(vec.begin() + i); 操作： 1234567vec.push_back(x)vec.pop_back()vec.size()vec.clear() // 清空vector中所有元素vec.insert(it, x) // 在it所指位置处插入一个元素，当前位置原先的元素及其之后的元素后移vec.erase(it) // 删除it所指位置的元素vec.erase(it1, it2) //删除[it1,it2)区间内的所有元素 set 初始化： 123set&lt;typename&gt; name;// set数组set&lt;typename&gt; arrayname[size]; 访问： 1234// 通过迭代器set&lt;typename&gt;::iterator it = name.begin();*it; it++; 操作： 1234567name.insert(x) // 复杂度O(logn)name.find(x) // 返回集合中值为x的迭代器，时间复杂度为O(logn)name.erase(it) // 删除it所指位置的元素，时间复杂度为O(1)name.erase(x) // 删除集合中值为x的元素，复杂度为0(logn)name.erase(it1, it2) // 删除[it1, it2)区间内的元素name.size() // 获取元素的个数，复杂度为O(1)name.clear() // 清空所有元素，复杂度为O(n) 注： set的作用是去重并升序排序 multiset允许元素重复 unordered_set:其只实现去重不实现排序，速度更快，原理为散列实现代替set的红黑树（自平衡二叉树）实现 string 初始化： 12345string str = &quot;abcd&quot;;cin&gt;&gt;str; cout&lt;&lt;str;// scanf不能输入stringprintf(&quot;%s&quot;, str.c_str()); 访问元素： 123456// 通过下标// 通过迭代器：string::iterator it = str.begin();it++;*it; 常用函数： 12345678910111213141516171819str1 += str2; // 将str2拼接到str1后面str1 = str1 + str2;// ==, !=, &lt;, &lt;=, &gt;, &gt;=:以字典序比较两个字符串str.length();str.size();str.insert(pos, string); // 从下标为pos的位置开始插入字符串，该位置及其之后的元素全部后移str.insert(it, it1, it2); // 从it所指位置开始插入it1到it2之间的元素str.erase(it); // 删除单个元素str.erase(it1, it2); // 删除一个区间内的所有元素str.erase(pos, length); // 删除下标为pos开始的length个元素str.clear(); // 清空元素str.substr(pos, len); // 取出len个元素string::npos; // find函数失配时的返回值，常量-1或4294967295str1.find(str2); // 当str2是str1的子串的时候，返回第一次出现的位置，否则返回string::npos,复杂度为O(mn)str.replace(pos, len, str2);str.replace(it1, it2, str2); // 将范围内的字符串替换为str2，修改了原字符串 map 初始化： 1map&lt;typename1, typename2&gt; mp; // key可以为STL类型，但是不能用数组类型 访问元素： 12345678// 元素按照key的大小升序排序// 通过下标访问// 通过迭代器：map&lt;typename1, typename2&gt;::iterator it;it-&gt;first; it-&gt;second; 常用函数： 123456mp.find(key); // 返回key对应的元素的迭代器mp.erase(it);mp.erase(key);mp.erase(it1, it2);mp.size();mp.clear(); queue 初始化： 1queue&lt;typename&gt; name; 访问元素： 12q.front(); // 最先进入的元素; q.back(); 常用函数： 123456q.front();q.back();q.pop();q.push(x);q.empty();q.size(); priority_queue 初始化： 1priority_queue&lt;typename&gt; name; // 大顶堆 访问元素： 1q.top(); 常用函数： 12345q.push(x); // O(logn)q.top(); // O(1)q.pop(); // O(logn)q.empty(); // O(1)q.size() 自定义优先级队列： 12345678910111213141516171819202122// 基本数据类型：// 小顶堆：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;// 大顶堆(默认)：priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;// 结构体：// 重载&lt;符号：写在结构体里面friend bool operator &lt; (student a, student b){ return a.age &lt; b.age;//大顶堆 return a.age &gt; b.age;//小顶堆}priority_queue&lt;student&gt; q;// 重载：写在结构体外面struct cmp{ bool operator () (fruit f1, fruit f2){ return f1.price &lt; f2.price;//大顶堆 return f1.price &gt; f2.price;//小顶堆 }}priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q; stack 初始化： 1stack&lt;typename&gt; s; 访问元素： 1s.top(); 常用函数： 12345s.push(x);s.top();s.pop();s.empty();s.size(); pair 初始化： 123// utility头文件，包含了map头文件也就是包含了utility, map的元素为元组pair&lt;typename1, typename2&gt; name(e1, e2);p = make_pair(e1, e2); 访问元素： 12p.first;p.second; 常用函数： ==, !=, &lt;, &lt;=, &gt;, &gt;=,先比较first，再比较second algorithm12345678910111213max(a, b);min(a, b);abs(x);swap(a, b);reverse(it1, it2); // 将[it1, it2)范围内的元素翻转next_permutation(a, a + 5); // 返回下一个全排列fill(a, a + 5, 233); // 将数组指定范围内填充为指定数字sort(it1, it2, cmp); // it为指针或者迭代器bool cmp(int i1, int i2){ return i1 &gt; i2;//递减排列}lower_bound(it1, it2, val); // 返回第一个&gt;=val的元素, 否则返回可以插入该元素的指针或者迭代器, 找到则返回指针或迭代器upper_bound(it1, it2, val); // 返回第一个&gt;val的元素","link":"/blog/2022/04/29/%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%802/"},{"title":"机器学习基本概念","text":"机器学习：寻找一个函数的能力 在语音识别中，这个函数将一段语音转化为文字；在图像分类中，这个函数得到图片的类别；在下围棋中，这个函数获取下一步的棋子应该下在什么地方 Regression：寻找输出连续值的函数 classification：寻找输出离散值的函数，alpha go也可以看作一个分类的任务 structure learning：让机器创造一些东西，包括结构化的图片或者文档 模型: $y=b+wx_1$ 特征$x_1$，权重$w$，偏置$b$，标签$\\hat{y}$，损失函数$L(b,w)$ ​ mean absolute errorMAE: $e=|y-\\hat{y}|$ ​ Mean square error(MSE): $e=(y-\\hat{y})^2$ Optimization: 找到最佳的$w$, $b$使得$w^*,b^*=argmin\\ L$ ​ Gradient descent: 首先随机初始化，之后计算关于$w,b$的梯度，更新$w,b$，$w^1\\leftarrow W^0-\\eta\\frac{\\partial L}{\\partial w}$","link":"/blog/2022/05/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"深度学习基础概念","text":"普通的线性模型不能满足更加复杂的需求 更加复杂的曲线可以用一系列曲线叠加的方式得到，这样的曲线抽象为$y=c\\frac{1}{1+e^{-(b+wx_1)}}$，即sigmoid函数$$r = b + Wx\\a = \\sigma(r)\\y = b + c^Ta\\y = b + c^T \\ \\sigma(b + Wx)$$除了模型变复杂之外，损失函数和优化的过程是一样的 另外一种激活函数ReLU：$c\\ max(0, b + wx_1)$ rectified linear unit，两个ReLU可以生成一个hard sigmoid 可以使模型变得更加复杂，也就是增加层数。但是不能将网络变得过于复杂，会出现过拟合现象 为什么不将网络直接变胖，而是需要变深呢？","link":"/blog/2022/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"Colab和Pytorch","text":"李宏毅课程中Colab, Pytorch总结 Colab 点击+ Code来添加code cell，点击+ Text来添加text cell，还有将cell上移以及下移的选项，可以将cell删除 在code cell中有两种命令可以输入，一种是python代码，直接输入即可；另一种是shell命令，在命令的前面需要加上! 命令的前面加上!，会先执行这个命令，之后就会杀掉这个进程，而在命令的前面加上%就会影响和这个jupyter相关的进程，称为magic command，可以查看https://ipython.readthedocs.io/en/stable/interactive/magics.html来知道更多的magic command 更换为使用GPU：点击Runtime-点击Change Runtime Type-选择GPU，更换runtime的操作会重启这个session 点击cell前面的运行按钮就会执行这个cell的代码，也可以点击runtime里面的选项来运行代码 查看抽到的GPU类型!nvidia-smi，有三种可能性P100&gt;T4&gt;k80 通过google drive下载文件，google drive分享的文件如下链接https://drive.google.com/open?id=xxxxxx，这个xxxxxx就是文件ID，使用下列命令来下载`!gdown –id ‘xxxxxx’ –output pikachu.png` 下载之后的文件可以通过点击文件夹图标查看，这些文件都是暂时储存的，在session结束之后就会被清理 可以点击上载图标来上传本地文件，可以下载文件 可以不用每次都上传以及下载文件，直接将google drive挂载到colab即可，首先导入包from google.colab import drive之后挂载drive.mount('/content/drive')","link":"/blog/2022/05/06/Colab%E5%92%8CPytorch/"},{"title":"Docker总结","text":"总结Docker的使用小知识 Docker使得程序的部署变得简单，Docker依赖的底层技术支持包括namespace实现进程之间的隔离，Control Groups来完成资源控制，资源包括核心数、内存和硬盘等等。依赖Union file sstem完成Container和image的分层。 镜像：分层的，是只读的，镜像可以理解为一个树状的结构，依赖关系体现在dockerfile文件中 容器：通过image来创建，在image上又添加了一层，这一层可以读写 仓库：dockerhub 容器的启动过程： 检查镜像是否存在，假如不存在下载 利用镜像创建一个容器 启动刚刚创建的容器 分配一个文件系统给容器，相当于在镜像层外挂载一个可读可写层 从宿主机的网桥接口中桥接一个给容器 从网桥中分一个IP地址给容器 执行用户指定的yinys","link":"/blog/2022/05/16/Docker%E6%80%BB%E7%BB%93/"},{"title":"卜算法学习笔记-lecture1-绪论","text":"算法的概念算法是指给出解决问题的操作步骤之后，无论是人还是机器都可以按照步骤机械性的执行得到问题的结果。我们在日常生活中回遇到各种的实际问题遇到之后的解决流程如下： 首先在一系列世纪问题中找到一个特定的topic，得到一个实际问题，在这个实际问题的基础之上我们可以抽象出数学问题，之后通过对该数学问题的观察，特别是对输入输出结构的观察，得到解决问题的算法。面对一个数学问题，我们首先问自己以下几个问题。 这个问题的最简单版本是否可以解决，假如不可以，我们可以降低问题的难度直到简单版本可以解决； 问题是否可以拆分为小问题，假如可以拆分，那么采用devide andconquer方法，如果有最优子结构，可以尝试动态规划，还有短视的策略贪心可以使用； 可行解的形式是什么，是否采用枚举办法，枚举时需要注意剪枝； 问题的解是否可以通过微小扰动变为另一种形式，这种可以采用逐步改进的办法解决问题，包括线性规划、局部搜索和半退火、网络流等； 基于旅行商问题介绍三种算法设计过程traveling salesman problem, TSP 输入：结点集合$V={v_1,…,v_n}$，以及结点之间的距离矩阵$D = (d_{i,j}) \\in R^{n\\times n}$,其中$d_{i,j}$表示节点$i$与节点$j$之间的距离； 输出：最短的环游路线，即从任意节点作为出发点，经过每个节点一次且仅一次，最终返回出发点的里程最短的环游；分而治之算法设计过程简介我们需要观察这个问题是否可以分解成简单实例，并且简单实例的解是否可以组合出复杂实例的解。 第一种尝试，我们尝试减少结点数，可以看到，我们可以很容易的将五个结点的实例变为四个结点的实例，但是简单实例不太容易组合成复杂实例; 第二种尝试，求解一个辅助问题，计算从起始结点$s$出发，经过中间结点集合$S$，最终达到目的节点$x$的最短路径，其长度计为$M(s,S, x)$; 可以看到在第二种尝试之下可以将这个问题分解为简单实例并可以合起来组成复杂实例。以5个结点的实例为例，包含结点$a,b,c,d,e$，以$a$为起始节点，那么可以从$b,c,e$返回起点，最短里程可以表示为$min{d_{b,a} + M(a,{c,d},b), d_{c,a} + M(a,{b,d},c), d_{e,a} + M(a,{c,b},e)}$这个算法可以表示为以下伪代码计算$M(s,S,x)$的伪代码算法的复杂度计算如下，我们需要枚举所有的结点子集$S$，所以总共有$2^n$个子集，路线起点确定，但是终点$x$有$n$种可能，所以总共要$O(2^nn)$才能计算出$M(s,S,x)$表格的值，计算出来之后还要经过$n$次比较的到最终的结果，Bellman-held-karp的复杂度为$O(2^n n^2)$. 逐步改进的算法设计流程基本过程是从问题的一个粗糙的，质量不太高的完整可行解开始，不断改进，直到获得满意的解为止，一般性框架为。求解过程中需要关注三个方面： 初始粗糙可行解的选择； 可行解的改进办法，也即扰动办法； 算法的终止条件，常见的终止条件包括当前的可行解无法进一步改进；迭代次数超过预先定义的值；当前可行解的质量超过预先定义的阈值； 智能枚举算法设计流程通过观察解的形式来枚举 枚举边的各种情况，最终的解的形式是边的集合，枚举各种边是否存在的情况，在这个过程中可以进行剪枝 枚举点的各种情况，也就是将环游表示成$X=x_1,x_2,…,x_{n-2},x_i \\in V （1\\leq i \\leq n - 2)$.","link":"/blog/2022/08/31/%E5%8D%9C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-lecture1-%E7%BB%AA%E8%AE%BA/"},{"title":"模式识别与机器学习学习笔记-lecture1-绪论","text":"概述模式：存在于世间和空间中可观察的物体，如果我们可以区别他们是否相同或是否相似，都可以称之为模式。 模式的直观特性： 可观察性 可区分性 相似性 模式识别：对周围物体的认识、人的识别、声音的辨别、气味的分辨 数据聚类目标：用某种相似性度量的方法见原始数据组成有意义的和有用的各种数据集是一种非监督学习的方法，解决方案是数据驱动的 统计分类基于概率统计模型得到各类别的特征向量的分布，以取得分类的方法；特征向量分布的获得是基于一个类别已知的训练样本集；是一种监督分类的方法，分类器是概念驱动的； 结构模式识别该方法通过考虑识别对象的各部分之间的联系来达到识别分类的目的；识别采用结构匹配的形式，通过计算一个匹配程度值（matching score）来评估一个未知的对象或位未知对象某些部分与某种典型模式的关系如何；当制定出来一组可以描述对象部分之间关系的规则后，可以应用一种特殊的结构模式识别方法-句法模式识别，来检查一个模式基元的序列是否遵守某种规则，即句法规则或语法； 神经网络由一系列互相联系的、相同的单元（神经元）组成，相互间的联系可以在不同的神经元之间传递增强或抑制信号；增强或抑制是通过调整神经元相互间联系的权重系数来实现；神经网络可以实现监督和非监督学习条件下的分类； 监督学习监督学习是从有标记的训练数据来推断或建立一个模型 无监督学习无监督学习与监督学习的不同之处在于，没有任何训练样本，需要直接对数据进行建模，寻找数据的内在结构及规律，如类别和聚类； 半监督学习利用少量的标注样本和大量的未标注样本进行训练和分类 增强学习机器人选择一个动作用于环境，环境接受该动作后状态发生变化，同时产生一个强化信号反馈回来，机器人根据强化信号和环境当前状态再选择下一个动作； 集成学习ensemble learning指联合训练多个弱分类器并通过集成策略将弱分类器组合使用；常见的集成策略有：boosting, bagging, random subspace, stacking；常见的算法主要有：决策树、随机森林、adaboost, GBDT, DART等； 深度学习源于人工神经网络的研究，通过层次化模型结构可从低层原始特征中逐渐抽象出高层次的语义特征； 元学习meta learning学会学习，利用以往的知识经验来指导新任务的学习，具有学会学习的能力 多任务学习联合训练多个学习任务 多标记学习处理的数据集中的每个样本可同时存在多个类标 对抗学习系统构成模式识别系统 机器学习","link":"/blog/2022/08/31/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-lecture1-%E7%BB%AA%E8%AE%BA/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/blog/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/blog/tags/icarus/"},{"name":"makefile","slug":"makefile","link":"/blog/tags/makefile/"},{"name":"基础","slug":"基础","link":"/blog/tags/%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","link":"/blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"docker","slug":"docker","link":"/blog/tags/docker/"},{"name":"算法","slug":"算法","link":"/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"模式识别","slug":"模式识别","link":"/blog/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"}],"categories":[{"name":"网站创建","slug":"网站创建","link":"/blog/categories/%E7%BD%91%E7%AB%99%E5%88%9B%E5%BB%BA/"},{"name":"个人小记","slug":"个人小记","link":"/blog/categories/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E8%AE%B0/"},{"name":"linux","slug":"linux","link":"/blog/categories/linux/"},{"name":"刷题笔记","slug":"刷题笔记","link":"/blog/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"机器学习-李宏毅","slug":"机器学习-李宏毅","link":"/blog/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"卜算法","slug":"卜算法","link":"/blog/categories/%E5%8D%9C%E7%AE%97%E6%B3%95/"},{"name":"模式识别与机器学习","slug":"模式识别与机器学习","link":"/blog/categories/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]}